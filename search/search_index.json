{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Traces analyzer See Metadata Extraction .","title":"Traces analyzer"},{"location":"#traces-analyzer","text":"See Metadata Extraction .","title":"Traces analyzer"},{"location":"metadata_extraction/","text":"Metadata extraction This page describes how metadata will be extracted from the traces. Goal Based on the four transaction traces (2 normal, 2 reverse order), we automatically determine several labels and metadata related to TOD. Danger This does not detect if the amount of a Selfedestruct changed, as this is directly taken from the state and not stored in the stack or memory. Are there other TODs that are not visible in traces? Traces preprocessing Traces input As inputs we take the execution traces from the transactions. These are based on the non-finalized EIP-3155 EVM trace specification. Note We require the \"pc\", \"op\", \"stack\" and \"depth\" fields. For deeper analysis, the \"memory\" field should also be present, eg to identify the CALL input. Here is an example trace for an SLOAD instruction: { \"pc\": 1157, \"op\": 84, \"gas\": \"0x1f7b1\", \"gasCost\": \"0x834\", \"stack\": [ \"0xd0e30db0\", \"...\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\" ], \"depth\": 2, \"returnData\": \"0x\", \"refund\": \"0x0\", \"memSize\": \"96\", \"opName\": \"SLOAD\" } Map each JSON to a TraceEvent This step simply maps a trace event from JSON to a python class ( TraceEvent ). Currently this is only implemented for traces generated with REVM (based on EIP-3155). However, new implementations could map other traces formats to TraceEvent , as long as the necessary information is included in the trace. Parse Instruction s Here, we parse the instructions and keep track in which contract they were executed. We start the process with an initial CallFrame , which stores who created the transaction and which contract/EOA is called. Then we iterate through the TraceEvent s, always looking at two successive TraceEvent s. Based on these events we create an Instruction object, which specifies the EVM instruction, its inputs and also its outputs. For some instructions the call context is important, so we link the current CallFrame to the instruction. For instance, an SLOAD instruction loads the data from the current contracts storage. If we encounter a call instruction ( CALL , STATICCALL , CALLCODE or DELEGATECALL ) we create a new CallFrame . On a STOP , RETURN , REVERT or SELFDESTRUCT we mark the current one as reverted and go back to the previous CallFrame . If the depth of the next event is one lower than the current one, we assume an exceptional halt and also revert the current transaction. If the depth of the next event is unexpected, we throw an UnexpectedDepthChange Exception. The Instruction includes: opcode program_counter call_frame stack_inputs stack_outputs memory_input memory_output data (additional fields based on the instruction type, eg key for SLOAD ) Warning How should we treat inputs/outputs from/to non-stack? in particular, the memory for eg calls? Analysis The analyzers are built in a way, that they don't need access to the whole trace at once. This way, we do not need to load the whole trace into memory at the same time, but instead iterate through the events and analyze them on the go. This is mainly a memory improvement. Instruction effect changes To understand, where the TOD occurs we compare the transaction trace from the normal and attack executions. At each iteration, we compare the Instruction s and stop as soon as we find the TOD source. If two instructions have a different output (eg an SLOAD that loads a different value from storage), we consider them to be the TOD source. If this did not happen yet, but two instructions differ otherwise (inputs, program counter, etc), we take the previous instructions as TOD source. For example, this can happen if a CALL occurs and in one trace there is enough balance to do this, while the other trace has insufficient balance to do so. Requires : comparison of two traces access to Instruction s Labels : TOD-source-instruction Warning Check if this also works for reverts. Note There could be multiple instructions that are directly affected by the previous transaction, however for all but the first instruction, it is hard to differentiate between a direct effect of the previous transaction, or an indirect effect through the first divergent instruction. Instruction input changes To understand, which instructions are affected by the TOD, we compare if the same instructions were executed, and if they were given the same inputs. For each instruction we count how often it has been exected in each trace. We identify the instruction by the code_address, pc, opcode and inputs. For instructions in trace A, we increment the counter. For instructions in the other trace, decrement it. Thus, if the instruction occurs in both traces, the count will balance to 0. If the inputs differ, we will have two different elements, one with a +1 count and one with -1. At the end, we group the instructions only by code_address, pc and opcode, so instructions with different inputs will be grouped together. These are matched between the traces to identify which parameters have changed and outputted as such. If no match exists, we output them as only being executed by one trace. Requires : comparison of two traces access to Instruction s Labels : TOD-Amount, TOD-Recipient, TOD-Selfdestruct, (TOD-Transfer also uses CALL ) ether profits list of affected instructions If this includes inputs from the memory, further: call input changes log changes token profits (through log changes) Instruction usage We record all executed unique instructions, eg to understand if hashing was used. We group this by the contract address that executed them. Requires : access to Instruction s access to CallFrame s Labels : cryptography usage (hashing, signatures) usage of recently introduce opcodes Warning Solidity uses keccak256 internally for mappings. Some detection tools based on the source code may understand Solidity mappings, but not usage of keccak256 in other cases. Not yet covered usage of precompiled contracts (see https://www.evm.codes/precompiled ) attacker-preconditions (eg. if the address from the attacker was returned from a SLOAD or a SLOAD with the attackers address as index returned != 0? Hard to understand without information flow analysis) control flow differences (where and through what? implement eg with changes or by comparing instructions) attack symmetry (if the order was different, would the \"victim\" be an \"attacker\"?) output differences (particularly useful, if we group by instruction+inputs => sampe input that yields different output is probably TOD affected)","title":"Metadata extraction"},{"location":"metadata_extraction/#metadata-extraction","text":"This page describes how metadata will be extracted from the traces.","title":"Metadata extraction"},{"location":"metadata_extraction/#goal","text":"Based on the four transaction traces (2 normal, 2 reverse order), we automatically determine several labels and metadata related to TOD. Danger This does not detect if the amount of a Selfedestruct changed, as this is directly taken from the state and not stored in the stack or memory. Are there other TODs that are not visible in traces?","title":"Goal"},{"location":"metadata_extraction/#traces-preprocessing","text":"","title":"Traces preprocessing"},{"location":"metadata_extraction/#traces-input","text":"As inputs we take the execution traces from the transactions. These are based on the non-finalized EIP-3155 EVM trace specification. Note We require the \"pc\", \"op\", \"stack\" and \"depth\" fields. For deeper analysis, the \"memory\" field should also be present, eg to identify the CALL input. Here is an example trace for an SLOAD instruction: { \"pc\": 1157, \"op\": 84, \"gas\": \"0x1f7b1\", \"gasCost\": \"0x834\", \"stack\": [ \"0xd0e30db0\", \"...\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\" ], \"depth\": 2, \"returnData\": \"0x\", \"refund\": \"0x0\", \"memSize\": \"96\", \"opName\": \"SLOAD\" }","title":"Traces input"},{"location":"metadata_extraction/#map-each-json-to-a-traceevent","text":"This step simply maps a trace event from JSON to a python class ( TraceEvent ). Currently this is only implemented for traces generated with REVM (based on EIP-3155). However, new implementations could map other traces formats to TraceEvent , as long as the necessary information is included in the trace.","title":"Map each JSON to a TraceEvent"},{"location":"metadata_extraction/#parse-instructions","text":"Here, we parse the instructions and keep track in which contract they were executed. We start the process with an initial CallFrame , which stores who created the transaction and which contract/EOA is called. Then we iterate through the TraceEvent s, always looking at two successive TraceEvent s. Based on these events we create an Instruction object, which specifies the EVM instruction, its inputs and also its outputs. For some instructions the call context is important, so we link the current CallFrame to the instruction. For instance, an SLOAD instruction loads the data from the current contracts storage. If we encounter a call instruction ( CALL , STATICCALL , CALLCODE or DELEGATECALL ) we create a new CallFrame . On a STOP , RETURN , REVERT or SELFDESTRUCT we mark the current one as reverted and go back to the previous CallFrame . If the depth of the next event is one lower than the current one, we assume an exceptional halt and also revert the current transaction. If the depth of the next event is unexpected, we throw an UnexpectedDepthChange Exception. The Instruction includes: opcode program_counter call_frame stack_inputs stack_outputs memory_input memory_output data (additional fields based on the instruction type, eg key for SLOAD ) Warning How should we treat inputs/outputs from/to non-stack? in particular, the memory for eg calls?","title":"Parse Instructions"},{"location":"metadata_extraction/#analysis","text":"The analyzers are built in a way, that they don't need access to the whole trace at once. This way, we do not need to load the whole trace into memory at the same time, but instead iterate through the events and analyze them on the go. This is mainly a memory improvement.","title":"Analysis"},{"location":"metadata_extraction/#instruction-effect-changes","text":"To understand, where the TOD occurs we compare the transaction trace from the normal and attack executions. At each iteration, we compare the Instruction s and stop as soon as we find the TOD source. If two instructions have a different output (eg an SLOAD that loads a different value from storage), we consider them to be the TOD source. If this did not happen yet, but two instructions differ otherwise (inputs, program counter, etc), we take the previous instructions as TOD source. For example, this can happen if a CALL occurs and in one trace there is enough balance to do this, while the other trace has insufficient balance to do so. Requires : comparison of two traces access to Instruction s Labels : TOD-source-instruction Warning Check if this also works for reverts. Note There could be multiple instructions that are directly affected by the previous transaction, however for all but the first instruction, it is hard to differentiate between a direct effect of the previous transaction, or an indirect effect through the first divergent instruction.","title":"Instruction effect changes"},{"location":"metadata_extraction/#instruction-input-changes","text":"To understand, which instructions are affected by the TOD, we compare if the same instructions were executed, and if they were given the same inputs. For each instruction we count how often it has been exected in each trace. We identify the instruction by the code_address, pc, opcode and inputs. For instructions in trace A, we increment the counter. For instructions in the other trace, decrement it. Thus, if the instruction occurs in both traces, the count will balance to 0. If the inputs differ, we will have two different elements, one with a +1 count and one with -1. At the end, we group the instructions only by code_address, pc and opcode, so instructions with different inputs will be grouped together. These are matched between the traces to identify which parameters have changed and outputted as such. If no match exists, we output them as only being executed by one trace. Requires : comparison of two traces access to Instruction s Labels : TOD-Amount, TOD-Recipient, TOD-Selfdestruct, (TOD-Transfer also uses CALL ) ether profits list of affected instructions If this includes inputs from the memory, further: call input changes log changes token profits (through log changes)","title":"Instruction input changes"},{"location":"metadata_extraction/#instruction-usage","text":"We record all executed unique instructions, eg to understand if hashing was used. We group this by the contract address that executed them. Requires : access to Instruction s access to CallFrame s Labels : cryptography usage (hashing, signatures) usage of recently introduce opcodes Warning Solidity uses keccak256 internally for mappings. Some detection tools based on the source code may understand Solidity mappings, but not usage of keccak256 in other cases.","title":"Instruction usage"},{"location":"metadata_extraction/#not-yet-covered","text":"usage of precompiled contracts (see https://www.evm.codes/precompiled ) attacker-preconditions (eg. if the address from the attacker was returned from a SLOAD or a SLOAD with the attackers address as index returned != 0? Hard to understand without information flow analysis) control flow differences (where and through what? implement eg with changes or by comparing instructions) attack symmetry (if the order was different, would the \"victim\" be an \"attacker\"?) output differences (particularly useful, if we group by instruction+inputs => sampe input that yields different output is probably TOD affected)","title":"Not yet covered"}]}
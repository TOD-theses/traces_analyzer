{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Traces analyzer See Metadata Extraction .","title":"Traces analyzer"},{"location":"#traces-analyzer","text":"See Metadata Extraction .","title":"Traces analyzer"},{"location":"metadata_extraction/","text":"Metadata extraction This section describes how labels will be extracted from the traces. Goal Based on the four transaction traces (2 normal, 2 reverse order), automatically determine several labels and metadata related to TOD. Danger This does not detect if the amount of a Selfedestruct changed. In general, this is not detected by my method. Are there other TODs that are not visible in traces? Planned implementation Traces data Here is an example for one event of an executed SLOAD instruction: { \"pc\": 1157, \"op\": 84, \"gas\": \"0x1f7b1\", \"gasCost\": \"0x834\", \"stack\": [ \"0xd0e30db0\", \"0x3d2\", \"0x62884461f1460000\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\", \"0x0\", \"0x62884461f1460000\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\" ], \"depth\": 2, \"returnData\": \"0x\", \"refund\": \"0x0\", \"memSize\": \"96\", \"opName\": \"SLOAD\" } Warning The EIP-3155 also specifies an optional \"memory\" field. This is not included by REVM per default. However, it is necessary to understand inputs and outputs from some instructions, eg CALL and LOGx. Traces preprocessing In general, we try not to load the whole trace into the memory. To achieve this goal, we iterate through the lines and process them on the go. Between each processing step we only pass the necessary data forward and forget all irrelevant data. Map each JSON to a TraceEvent This step simply maps a trace event from JSON to a python class ( TraceEvent ). Currently this is only implemented for traces generated with REVM (based on EIP-3155). However, new implementations could map other traces formats to TraceEvent , as long as the necessary information is included in the trace. Create EnvironmentChange s Based on two successive TraceEvent s, compute the change between the environments. This includes following changes: StackChange MemoryChange ProgramCounterChange CallDepthChange (?) ReturnDataChange (?) Parse Instruction s Based on two successive TraceEvent s, parse the executed instruction. An Instruction includes: op inputs (as fields, depending on the instruction. eg key for SLOAD ) outputs (as fields, depending on the instruction. eg value for SLOAD ) NOTE: Maybe inputs and outputs should be available as lists too, to make it easier to compare? Warning How should we treat inputs/outputs from/to non-stack? in particular, the memory for eg calls? Track CallFrame s Based on the TraceEvent s and CallDepthChange s, keep track of the call stack. The call stack is a list of CallFrame s, with the last one being the current call frame. A CallFrame includes: depth from to Note We probably want to do this before/while parsing the instructions. The callframe is semantically connected to the instructions, eg a SLOAD loads data from the current contract, which is only known through the current CallFrame . Analysis Instruction effect changes To understand, where the TOD occurs we compare the transaction trace from both cases. At each iteration, we compare the EnvironmentChange s of both traces. The first time they differ, is the point at which the same instruction had a different effect. This could happen at a SLOAD if the storage is influenced by the other transaction, a BALANCE , etc. This detection will simply report the instruction that was executed before the traces diverge. Requires : comparison of two traces access to EnvironmentChange s access to Instruction s Labels : TOD-source-instruction Warning Check if this also works for reverts. Note There could be multiple instructions that are directly affected by the previous transaction, however for all but the first instruction, it is hard to differentiate between a direct effect of the previous transaction, or an indirect effect through the first divergent instruction. Note The same could be achieved by looking at the instruction outputs. However, this would require an exact modelling of all instruction outputs. Checking the stack, memory and pc is easier and less error-prone. Instruction input changes To understand, which instructions are affected by the TOD, we compare if the same instructions were executed, and if they were given the same inputs. Create a counter that counts how often an instruction has been called. An instruction is identified by (pc, inputs). For instructions in trace A, increment it. For instructions in the other trace, decrement it. Requires : comparison of two traces access to Instruction s Labels : TOD-Amount, TOD-Recipient, TOD-Transfer, TOD-Selfdestruct ether profits list of affected instructions If this includes inputs from the memory, further: call input changes log changes token profits (through log changes) Instruction usage We record all executed unique instructions, eg to understand if hashing was used. We group this by the contract address that executed them. Requires : access to Instruction s access to CallFrame s Labels : cryptography usage (hashing, signatures) usage of recently introduce opcodes Warning Solidity uses keccak256 internally for mappings. Some detection tools based on the source code may understand Solidity mappings, but not usage of keccak256 in other cases. Not yet covered usage of precompiled contracts (see https://www.evm.codes/precompiled ) attacker-preconditions (eg. if the address from the attacker was returned from a SLOAD or a SLOAD with the attackers address as index returned != 0? Maybe hard to understand without information flow analysis) control flow differences (where and through what? implement eg with changes or by comparing instructions) attack symmetry (if the order was different, would the \"victim\" be an \"attacker\"?)","title":"Metadata extraction"},{"location":"metadata_extraction/#metadata-extraction","text":"This section describes how labels will be extracted from the traces.","title":"Metadata extraction"},{"location":"metadata_extraction/#goal","text":"Based on the four transaction traces (2 normal, 2 reverse order), automatically determine several labels and metadata related to TOD. Danger This does not detect if the amount of a Selfedestruct changed. In general, this is not detected by my method. Are there other TODs that are not visible in traces?","title":"Goal"},{"location":"metadata_extraction/#planned-implementation","text":"","title":"Planned implementation"},{"location":"metadata_extraction/#traces-data","text":"Here is an example for one event of an executed SLOAD instruction: { \"pc\": 1157, \"op\": 84, \"gas\": \"0x1f7b1\", \"gasCost\": \"0x834\", \"stack\": [ \"0xd0e30db0\", \"0x3d2\", \"0x62884461f1460000\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\", \"0x0\", \"0x62884461f1460000\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\" ], \"depth\": 2, \"returnData\": \"0x\", \"refund\": \"0x0\", \"memSize\": \"96\", \"opName\": \"SLOAD\" } Warning The EIP-3155 also specifies an optional \"memory\" field. This is not included by REVM per default. However, it is necessary to understand inputs and outputs from some instructions, eg CALL and LOGx.","title":"Traces data"},{"location":"metadata_extraction/#traces-preprocessing","text":"In general, we try not to load the whole trace into the memory. To achieve this goal, we iterate through the lines and process them on the go. Between each processing step we only pass the necessary data forward and forget all irrelevant data.","title":"Traces preprocessing"},{"location":"metadata_extraction/#map-each-json-to-a-traceevent","text":"This step simply maps a trace event from JSON to a python class ( TraceEvent ). Currently this is only implemented for traces generated with REVM (based on EIP-3155). However, new implementations could map other traces formats to TraceEvent , as long as the necessary information is included in the trace.","title":"Map each JSON to a TraceEvent"},{"location":"metadata_extraction/#create-environmentchanges","text":"Based on two successive TraceEvent s, compute the change between the environments. This includes following changes: StackChange MemoryChange ProgramCounterChange CallDepthChange (?) ReturnDataChange (?)","title":"Create EnvironmentChanges"},{"location":"metadata_extraction/#parse-instructions","text":"Based on two successive TraceEvent s, parse the executed instruction. An Instruction includes: op inputs (as fields, depending on the instruction. eg key for SLOAD ) outputs (as fields, depending on the instruction. eg value for SLOAD ) NOTE: Maybe inputs and outputs should be available as lists too, to make it easier to compare? Warning How should we treat inputs/outputs from/to non-stack? in particular, the memory for eg calls?","title":"Parse Instructions"},{"location":"metadata_extraction/#track-callframes","text":"Based on the TraceEvent s and CallDepthChange s, keep track of the call stack. The call stack is a list of CallFrame s, with the last one being the current call frame. A CallFrame includes: depth from to Note We probably want to do this before/while parsing the instructions. The callframe is semantically connected to the instructions, eg a SLOAD loads data from the current contract, which is only known through the current CallFrame .","title":"Track CallFrames"},{"location":"metadata_extraction/#analysis","text":"","title":"Analysis"},{"location":"metadata_extraction/#instruction-effect-changes","text":"To understand, where the TOD occurs we compare the transaction trace from both cases. At each iteration, we compare the EnvironmentChange s of both traces. The first time they differ, is the point at which the same instruction had a different effect. This could happen at a SLOAD if the storage is influenced by the other transaction, a BALANCE , etc. This detection will simply report the instruction that was executed before the traces diverge. Requires : comparison of two traces access to EnvironmentChange s access to Instruction s Labels : TOD-source-instruction Warning Check if this also works for reverts. Note There could be multiple instructions that are directly affected by the previous transaction, however for all but the first instruction, it is hard to differentiate between a direct effect of the previous transaction, or an indirect effect through the first divergent instruction. Note The same could be achieved by looking at the instruction outputs. However, this would require an exact modelling of all instruction outputs. Checking the stack, memory and pc is easier and less error-prone.","title":"Instruction effect changes"},{"location":"metadata_extraction/#instruction-input-changes","text":"To understand, which instructions are affected by the TOD, we compare if the same instructions were executed, and if they were given the same inputs. Create a counter that counts how often an instruction has been called. An instruction is identified by (pc, inputs). For instructions in trace A, increment it. For instructions in the other trace, decrement it. Requires : comparison of two traces access to Instruction s Labels : TOD-Amount, TOD-Recipient, TOD-Transfer, TOD-Selfdestruct ether profits list of affected instructions If this includes inputs from the memory, further: call input changes log changes token profits (through log changes)","title":"Instruction input changes"},{"location":"metadata_extraction/#instruction-usage","text":"We record all executed unique instructions, eg to understand if hashing was used. We group this by the contract address that executed them. Requires : access to Instruction s access to CallFrame s Labels : cryptography usage (hashing, signatures) usage of recently introduce opcodes Warning Solidity uses keccak256 internally for mappings. Some detection tools based on the source code may understand Solidity mappings, but not usage of keccak256 in other cases.","title":"Instruction usage"},{"location":"metadata_extraction/#not-yet-covered","text":"usage of precompiled contracts (see https://www.evm.codes/precompiled ) attacker-preconditions (eg. if the address from the attacker was returned from a SLOAD or a SLOAD with the attackers address as index returned != 0? Maybe hard to understand without information flow analysis) control flow differences (where and through what? implement eg with changes or by comparing instructions) attack symmetry (if the order was different, would the \"victim\" be an \"attacker\"?)","title":"Not yet covered"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Traces analyzer The analysis is currently done in two steps: Parse instructions from traces (see Parsing ) Extract features of the instructions (see Feature Extraction ) TODO: assign definitions, labels and other metadata to contracts (or contract groups)","title":"Introduction"},{"location":"#traces-analyzer","text":"The analysis is currently done in two steps: Parse instructions from traces (see Parsing ) Extract features of the instructions (see Feature Extraction ) TODO: assign definitions, labels and other metadata to contracts (or contract groups)","title":"Traces analyzer"},{"location":"contract_attribution/","text":"Contract attribution Here, we describe how to attribute a label to specific contracts of the trace. TOD definitions write-write conflict: use the contract from the SSTORE instruction write-read conflict: use the contract from the SLOAD/... instruction instruction changes: use the contracts from all instructions between the SLOAD/... instruction and the CALL/... instruction Alternative ideas If the SLOAD is within a contract and the sink (call/log change) is in the parent contract, we would currently take both contracts. We could also only take the parent contract and say that the CALL was the problem, yielding a different output and taking it as a source (ignoring the inner workings of the CALL). However, the other way around, this does not work (An SLOAD is in the parent and the LOG is in the child).","title":"Contract attribution"},{"location":"contract_attribution/#contract-attribution","text":"Here, we describe how to attribute a label to specific contracts of the trace.","title":"Contract attribution"},{"location":"contract_attribution/#tod-definitions","text":"write-write conflict: use the contract from the SSTORE instruction write-read conflict: use the contract from the SLOAD/... instruction instruction changes: use the contracts from all instructions between the SLOAD/... instruction and the CALL/... instruction","title":"TOD definitions"},{"location":"contract_attribution/#alternative-ideas","text":"If the SLOAD is within a contract and the sink (call/log change) is in the parent contract, we would currently take both contracts. We could also only take the parent contract and say that the CALL was the problem, yielding a different output and taking it as a source (ignoring the inner workings of the CALL). However, the other way around, this does not work (An SLOAD is in the parent and the LOG is in the child).","title":"Alternative ideas"},{"location":"definitions/","text":"TOD definitions Here we will show several definitions of TOD. Sub-headers are used to indicate, that the definition is a specialization of the upper definition. Note We could differ between definitions that are focused on the outcome (taking the execution as a black-box) and definitions that are focused on the execution (ignoring the resulting state). eg \"differences in the resulting balances\" vs \"differences in the execution's ether flows\". TOD definitions World State Write-Write conflict Write-Read Call changes Ether flow changes Log changes Token flow changes World State A TOD occurs, when executing transactions in a different order yields different world states. The world state is a mapping from addresses to account states, and the account state includes: nonce balance storageRoot codeHash Thus, two transactions are TOD, iff the balance, the storage or the code of an account, or the nonce of a smart contract is dependent on the transaction order (the nonce of an EOA cannot be influenced by the transactions). Write-Write conflict A TOD occurs, when both transactions overwrite different values to the same storage location. An example of this is ERC-20 approve, where both transactions write to approved[victim][attacker] . The remaining amount of approved tokens is the write-value of the second transaction. Note Only for storage there is a relevant overwrite functionality. For balances, there is only a set-to-0 functionality with selfdestruct . For CREATE2 it is theoretically possible if there is also a Write-Read conflict (so the initialisation_code can fetch different data, depending on which transaction got executed first). For CREATE , the two creations will use different nonces and thus have different destinations. Write-Read A TOD occurs, when the first transactions modifies a value and the second transaction reads this value. The value could be stored in the storage or be an accounts balance. to the storage and the second transaction reads this value from the storage. Warning This definition also includes the case, where selfdestruct(recipient) writes and reads the balance. This would need special care in the implementation. Note This definition does not necessarily imply a world state change. For instance, assume a counter currently has a value 0 . The first transaction increments it to 1 . The second transaction makes an if (counter > 2) . There is a write-read conflict, however this does not affect the world state (neither in storage, logs, code, gas, etc.). Call changes A TOD occurs, if the existence of a call instruction, or its stack and memory inputs, depend on the transaction order. Type of calls: CALL, STATICCALL, CALLCODE, DELEGATECALL. However, mostly CALL is relevant, as the others do not impact state of other contracts (except CALLCODE value I guess). Note Should we include selfdestruct here? Ether flow changes A TOD occurs, if the sending of ether (source, recipient or amount) depends on the transaction order. Log changes A TOD occurs, if the existence of a log instruction, or its stack and memory inputs, depend on the transaction order. Token flow changes A TOD occurs, if the sending of tokens (source, recipient or amount) depends on the transaction order.","title":"TOD definitions"},{"location":"definitions/#tod-definitions","text":"Here we will show several definitions of TOD. Sub-headers are used to indicate, that the definition is a specialization of the upper definition. Note We could differ between definitions that are focused on the outcome (taking the execution as a black-box) and definitions that are focused on the execution (ignoring the resulting state). eg \"differences in the resulting balances\" vs \"differences in the execution's ether flows\". TOD definitions World State Write-Write conflict Write-Read Call changes Ether flow changes Log changes Token flow changes","title":"TOD definitions"},{"location":"definitions/#world-state","text":"A TOD occurs, when executing transactions in a different order yields different world states. The world state is a mapping from addresses to account states, and the account state includes: nonce balance storageRoot codeHash Thus, two transactions are TOD, iff the balance, the storage or the code of an account, or the nonce of a smart contract is dependent on the transaction order (the nonce of an EOA cannot be influenced by the transactions).","title":"World State"},{"location":"definitions/#write-write-conflict","text":"A TOD occurs, when both transactions overwrite different values to the same storage location. An example of this is ERC-20 approve, where both transactions write to approved[victim][attacker] . The remaining amount of approved tokens is the write-value of the second transaction. Note Only for storage there is a relevant overwrite functionality. For balances, there is only a set-to-0 functionality with selfdestruct . For CREATE2 it is theoretically possible if there is also a Write-Read conflict (so the initialisation_code can fetch different data, depending on which transaction got executed first). For CREATE , the two creations will use different nonces and thus have different destinations.","title":"Write-Write conflict"},{"location":"definitions/#write-read","text":"A TOD occurs, when the first transactions modifies a value and the second transaction reads this value. The value could be stored in the storage or be an accounts balance. to the storage and the second transaction reads this value from the storage. Warning This definition also includes the case, where selfdestruct(recipient) writes and reads the balance. This would need special care in the implementation. Note This definition does not necessarily imply a world state change. For instance, assume a counter currently has a value 0 . The first transaction increments it to 1 . The second transaction makes an if (counter > 2) . There is a write-read conflict, however this does not affect the world state (neither in storage, logs, code, gas, etc.).","title":"Write-Read"},{"location":"definitions/#call-changes","text":"A TOD occurs, if the existence of a call instruction, or its stack and memory inputs, depend on the transaction order. Type of calls: CALL, STATICCALL, CALLCODE, DELEGATECALL. However, mostly CALL is relevant, as the others do not impact state of other contracts (except CALLCODE value I guess). Note Should we include selfdestruct here?","title":"Call changes"},{"location":"definitions/#ether-flow-changes","text":"A TOD occurs, if the sending of ether (source, recipient or amount) depends on the transaction order.","title":"Ether flow changes"},{"location":"definitions/#log-changes","text":"A TOD occurs, if the existence of a log instruction, or its stack and memory inputs, depend on the transaction order.","title":"Log changes"},{"location":"definitions/#token-flow-changes","text":"A TOD occurs, if the sending of tokens (source, recipient or amount) depends on the transaction order.","title":"Token flow changes"},{"location":"feature_extraction/","text":"Feature extraction This page describes how features will be extracted from trace pairs. Instruction effect changes To understand, where the TOD occurs we compare the transaction trace from the normal and attack executions. At each iteration, we compare the Instruction s and stop as soon as we find the TOD source. If two instructions have a different output (eg an SLOAD that loads a different value from storage), we consider them to be the TOD source. If this did not happen yet, but two instructions differ otherwise (inputs, program counter, etc), we take the previous instructions as TOD source. For example, this can happen if a CALL occurs and in one trace there is enough balance to do this, while the other trace has insufficient balance to do so. Requires : comparison of two traces access to Instruction s Labels : TOD-source-instruction Warning Check if this also works for reverts. Note There could be multiple instructions that are directly affected by the previous transaction, however for all but the first instruction, it is hard to differentiate between a direct effect of the previous transaction, or an indirect effect through the first divergent instruction. Instruction changes To understand, which instructions are affected by the TOD, we compare if the same instructions were executed, and if they were given the same inputs. For each instruction we count how often it has been exected in each trace. We identify the instruction by the code_address, pc, opcode and inputs. For instructions in trace A, we increment the counter. For instructions in the other trace, decrement it. Thus, if the instruction occurs in both traces, the count will balance to 0. If the inputs differ, we will have two different elements, one with a +1 count and one with -1. At the end, we group the instructions only by code_address, pc and opcode, so instructions with different inputs will be grouped together. These are matched between the traces to identify which parameters have changed and outputted as such. If no match exists, we output them as only being executed by one trace. Requires : comparison of two traces access to Instruction s Labels : TOD-Amount, TOD-Recipient, TOD-Selfdestruct, (TOD-Transfer also uses CALL ) ether profits list of affected instructions If this includes inputs from the memory, further: call input changes log changes token profits (through log changes) Instruction usages We record all executed unique instructions, eg to understand if hashing was used. We group this by the contract address that executed them. Requires : access to Instruction s access to CallContext s Labels : cryptography usage (hashing, signatures) usage of recently introduce opcodes Warning Solidity uses keccak256 internally for mappings. Some detection tools based on the source code may understand Solidity mappings, but not usage of keccak256 in other cases. Not yet covered usage of precompiled contracts (see https://www.evm.codes/precompiled ) attacker-preconditions (eg. if the address from the attacker was returned from a SLOAD or a SLOAD with the attackers address as index returned != 0? Hard to understand without information flow analysis) control flow differences (where and through what? implement eg with changes or by comparing instructions) attack symmetry (if the order was different, would the \"victim\" be an \"attacker\"?) output differences (particularly useful, if we group by instruction+inputs => sampe input that yields different output is probably TOD affected) Taint Flow analysis We could also do taint flow analysis with a few modifications. If we replace the string values on the stack, memory and calldata with objects that store (value, written_by: Instruction and read_by: list[Instruction]) , then we would know which write did affect which reads and thus which instructions influenced which following instructions. This could be used for: - checking if the attackers address was used for some check (if conditions) or influenced the sink (both, directly or through sstore->sload/tstore->tload/...) - to reduce the number of vulnerable accounts in one source->sink flow (if we know the flow we know exactly which contracts are involved, instead of relying on heuristics that potentially include too many)","title":"Feature extraction"},{"location":"feature_extraction/#feature-extraction","text":"This page describes how features will be extracted from trace pairs.","title":"Feature extraction"},{"location":"feature_extraction/#instruction-effect-changes","text":"To understand, where the TOD occurs we compare the transaction trace from the normal and attack executions. At each iteration, we compare the Instruction s and stop as soon as we find the TOD source. If two instructions have a different output (eg an SLOAD that loads a different value from storage), we consider them to be the TOD source. If this did not happen yet, but two instructions differ otherwise (inputs, program counter, etc), we take the previous instructions as TOD source. For example, this can happen if a CALL occurs and in one trace there is enough balance to do this, while the other trace has insufficient balance to do so. Requires : comparison of two traces access to Instruction s Labels : TOD-source-instruction Warning Check if this also works for reverts. Note There could be multiple instructions that are directly affected by the previous transaction, however for all but the first instruction, it is hard to differentiate between a direct effect of the previous transaction, or an indirect effect through the first divergent instruction.","title":"Instruction effect changes"},{"location":"feature_extraction/#instruction-changes","text":"To understand, which instructions are affected by the TOD, we compare if the same instructions were executed, and if they were given the same inputs. For each instruction we count how often it has been exected in each trace. We identify the instruction by the code_address, pc, opcode and inputs. For instructions in trace A, we increment the counter. For instructions in the other trace, decrement it. Thus, if the instruction occurs in both traces, the count will balance to 0. If the inputs differ, we will have two different elements, one with a +1 count and one with -1. At the end, we group the instructions only by code_address, pc and opcode, so instructions with different inputs will be grouped together. These are matched between the traces to identify which parameters have changed and outputted as such. If no match exists, we output them as only being executed by one trace. Requires : comparison of two traces access to Instruction s Labels : TOD-Amount, TOD-Recipient, TOD-Selfdestruct, (TOD-Transfer also uses CALL ) ether profits list of affected instructions If this includes inputs from the memory, further: call input changes log changes token profits (through log changes)","title":"Instruction changes"},{"location":"feature_extraction/#instruction-usages","text":"We record all executed unique instructions, eg to understand if hashing was used. We group this by the contract address that executed them. Requires : access to Instruction s access to CallContext s Labels : cryptography usage (hashing, signatures) usage of recently introduce opcodes Warning Solidity uses keccak256 internally for mappings. Some detection tools based on the source code may understand Solidity mappings, but not usage of keccak256 in other cases.","title":"Instruction usages"},{"location":"feature_extraction/#not-yet-covered","text":"usage of precompiled contracts (see https://www.evm.codes/precompiled ) attacker-preconditions (eg. if the address from the attacker was returned from a SLOAD or a SLOAD with the attackers address as index returned != 0? Hard to understand without information flow analysis) control flow differences (where and through what? implement eg with changes or by comparing instructions) attack symmetry (if the order was different, would the \"victim\" be an \"attacker\"?) output differences (particularly useful, if we group by instruction+inputs => sampe input that yields different output is probably TOD affected)","title":"Not yet covered"},{"location":"feature_extraction/#taint-flow-analysis","text":"We could also do taint flow analysis with a few modifications. If we replace the string values on the stack, memory and calldata with objects that store (value, written_by: Instruction and read_by: list[Instruction]) , then we would know which write did affect which reads and thus which instructions influenced which following instructions. This could be used for: - checking if the attackers address was used for some check (if conditions) or influenced the sink (both, directly or through sstore->sload/tstore->tload/...) - to reduce the number of vulnerable accounts in one source->sink flow (if we know the flow we know exactly which contracts are involved, instead of relying on heuristics that potentially include too many)","title":"Taint Flow analysis"},{"location":"notes/","text":"Notes ERC20 Approval This is a case of a write-write conflict between the two transactions. Explanation Lets assume, that the victim already approved 100 tokens for the attacker ( approved[victim][attacker] == 100 ). Now, the victim tries to change this to 150 approved tokens instead. However, the attacker notices the transaction in the mempool and quickly withdraws the approved tokens with transferFrom. Attack scenario: approved[victim][attacker] = 0 (-= 100) --> Transfer(victim, attacker, 100) approved[victim][attacker] = 150 --> Approval(victim, attacker, 150) Reverse scenario writes: approved[victim][attacker] = 150 --> Approval(victim, attacker, 150) approved[victim][attacker] = 50 (-= 100) --> Transfer(victim, attacker, 50) Note This is the basic case. If the attacker has a bot with more logic they could abort/adapt their transfer in the reverse scenario. Detection From the traces that happened on the blockchain, we can check if: both transactions write to the same key and storage address there is a Transfer(victim, attacker, n) and later a Approval(victim, attacker, m) the victim writes the value m","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes"},{"location":"notes/#erc20-approval","text":"This is a case of a write-write conflict between the two transactions.","title":"ERC20 Approval"},{"location":"notes/#explanation","text":"Lets assume, that the victim already approved 100 tokens for the attacker ( approved[victim][attacker] == 100 ). Now, the victim tries to change this to 150 approved tokens instead. However, the attacker notices the transaction in the mempool and quickly withdraws the approved tokens with transferFrom. Attack scenario: approved[victim][attacker] = 0 (-= 100) --> Transfer(victim, attacker, 100) approved[victim][attacker] = 150 --> Approval(victim, attacker, 150) Reverse scenario writes: approved[victim][attacker] = 150 --> Approval(victim, attacker, 150) approved[victim][attacker] = 50 (-= 100) --> Transfer(victim, attacker, 50) Note This is the basic case. If the attacker has a bot with more logic they could abort/adapt their transfer in the reverse scenario.","title":"Explanation"},{"location":"notes/#detection","text":"From the traces that happened on the blockchain, we can check if: both transactions write to the same key and storage address there is a Transfer(victim, attacker, n) and later a Approval(victim, attacker, m) the victim writes the value m","title":"Detection"},{"location":"parsing/","text":"Parsing Planned results Note For the Outputs, we need at least the stack output, as we use this to detect TOD sources (eg for SLOAD and BALANCE). We don't include the call related data as these always reflect the inputs. At each instruction, we keep track which inputs it uses and which outputs it produces. The values it uses stores information, about which instruction lastly outputted it without modifying its value (eg a CALL passing memory data to calldata) and which instruction lastly modified its value (eg an ADD summing two inputs to a new output value). This helps us to track the information flow at a byte level, rather than grouping the values together per instruction. For instance, if a CALL takes multiple input parameters from the memory, the parameters will be composed of their own values with their own touched_by and modified_by fields. A tokenAmount would trace back to a different modifying instruction, than a token parameter in the same call. Planned parsing process To create the instruction, we need: instruction metadata (opcode, name, pc) access to storages to create input StorageAccessSets access to the stack after the instruction for some output StorageWrites (for the others, the storage access is enough, eg current memory + stack) call_context to link it for later analysis Information Flow To understand which instruction influenced the inputs of another instruction, we keep track which instructions modified a storage value. We keep track of the last instruction that modified the value. For instance, an ADD instruction will output a StorageValue with modified_by == ADD . However, a swap afterwards will only update the touched_by , the modified_by will continue to be the ADD instruction. Information Flow backtracking: From the instruction inputs, find the instructions that have written these input values. Recursively continue from these instructions' inputs. Start: instruction sink let instruction = instruction_sink let depends_on = set() let next_inputs = instruction.inputs while next_inputs { let inputs = next_inputs next_inputs = [] for input in inputs { for storage_access in input.storage_access_set { let instr = storage_access.modified_by depends_on.append(instr) next_inputs.append(instr) } } } Traces input As inputs we take the execution traces from the transactions. These are based on the non-finalized EIP-3155 EVM trace specification. Note We require the \"pc\", \"op\", \"stack\" and \"depth\" fields. For better instruction input and output analysis, the \"memory\" field should also be present, eg to identify the CALL and LOG inputs. Here is an example trace for an SLOAD instruction: { \"pc\": 1157, \"op\": 84, \"gas\": \"0x1f7b1\", \"gasCost\": \"0x834\", \"stack\": [ \"0xd0e30db0\", \"...\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\" ], \"memory\": \"0x00..080\", \"depth\": 2, \"returnData\": \"0x\", \"refund\": \"0x0\", \"memSize\": \"96\", \"opName\": \"SLOAD\" } Map each JSON to a TraceEvent This step simply maps a trace event from JSON to a python class ( TraceEvent ). Currently this is only implemented for traces generated with REVM (based on EIP-3155). However, new implementations could map other traces formats to TraceEvent , as long as the necessary information is included in the trace. Parse Instruction s and the CallTree Here, we parse the instructions and keep track in which contract they were executed. We start the process with an initial CallContext , which stores who created the transaction and which contract/EOA is called. Then we iterate through the TraceEvent s, always looking at two successive TraceEvent s. Based on these events we create an Instruction object, which specifies the EVM instruction, its inputs and also its outputs. For some instructions the call context is important, so we link the current CallContext to the instruction. For instance, an SLOAD instruction loads the data from the current contracts storage. If we encounter a call instruction ( CALL , STATICCALL , CALLCODE , DELEGATECALL , CREATE or CREATE2 ) we create a new CallContext . On a STOP , RETURN , REVERT or SELFDESTRUCT we mark the current one as reverted and go back to the previous CallContext . If the depth of the next event is one lower than the current one, we assume an exceptional halt and also revert the current transaction. If the depth of the next event is unexpected, we throw an UnexpectedDepthChange Exception. The Instruction includes: opcode name (mnemonic for opcode) program_counter call_context stack_inputs stack_outputs memory_input memory_output data (additional fields based on the instruction type, eg key for SLOAD )","title":"Parsing"},{"location":"parsing/#parsing","text":"","title":"Parsing"},{"location":"parsing/#planned-results","text":"Note For the Outputs, we need at least the stack output, as we use this to detect TOD sources (eg for SLOAD and BALANCE). We don't include the call related data as these always reflect the inputs. At each instruction, we keep track which inputs it uses and which outputs it produces. The values it uses stores information, about which instruction lastly outputted it without modifying its value (eg a CALL passing memory data to calldata) and which instruction lastly modified its value (eg an ADD summing two inputs to a new output value). This helps us to track the information flow at a byte level, rather than grouping the values together per instruction. For instance, if a CALL takes multiple input parameters from the memory, the parameters will be composed of their own values with their own touched_by and modified_by fields. A tokenAmount would trace back to a different modifying instruction, than a token parameter in the same call.","title":"Planned results"},{"location":"parsing/#planned-parsing-process","text":"To create the instruction, we need: instruction metadata (opcode, name, pc) access to storages to create input StorageAccessSets access to the stack after the instruction for some output StorageWrites (for the others, the storage access is enough, eg current memory + stack) call_context to link it for later analysis","title":"Planned parsing process"},{"location":"parsing/#information-flow","text":"To understand which instruction influenced the inputs of another instruction, we keep track which instructions modified a storage value. We keep track of the last instruction that modified the value. For instance, an ADD instruction will output a StorageValue with modified_by == ADD . However, a swap afterwards will only update the touched_by , the modified_by will continue to be the ADD instruction. Information Flow backtracking: From the instruction inputs, find the instructions that have written these input values. Recursively continue from these instructions' inputs. Start: instruction sink let instruction = instruction_sink let depends_on = set() let next_inputs = instruction.inputs while next_inputs { let inputs = next_inputs next_inputs = [] for input in inputs { for storage_access in input.storage_access_set { let instr = storage_access.modified_by depends_on.append(instr) next_inputs.append(instr) } } }","title":"Information Flow"},{"location":"parsing/#traces-input","text":"As inputs we take the execution traces from the transactions. These are based on the non-finalized EIP-3155 EVM trace specification. Note We require the \"pc\", \"op\", \"stack\" and \"depth\" fields. For better instruction input and output analysis, the \"memory\" field should also be present, eg to identify the CALL and LOG inputs. Here is an example trace for an SLOAD instruction: { \"pc\": 1157, \"op\": 84, \"gas\": \"0x1f7b1\", \"gasCost\": \"0x834\", \"stack\": [ \"0xd0e30db0\", \"...\", \"0xd7a8b5b72b22ea76954784721def9efafa7df99d65b759e7d1b78f9ee0094fbc\" ], \"memory\": \"0x00..080\", \"depth\": 2, \"returnData\": \"0x\", \"refund\": \"0x0\", \"memSize\": \"96\", \"opName\": \"SLOAD\" }","title":"Traces input"},{"location":"parsing/#map-each-json-to-a-traceevent","text":"This step simply maps a trace event from JSON to a python class ( TraceEvent ). Currently this is only implemented for traces generated with REVM (based on EIP-3155). However, new implementations could map other traces formats to TraceEvent , as long as the necessary information is included in the trace.","title":"Map each JSON to a TraceEvent"},{"location":"parsing/#parse-instructions-and-the-calltree","text":"Here, we parse the instructions and keep track in which contract they were executed. We start the process with an initial CallContext , which stores who created the transaction and which contract/EOA is called. Then we iterate through the TraceEvent s, always looking at two successive TraceEvent s. Based on these events we create an Instruction object, which specifies the EVM instruction, its inputs and also its outputs. For some instructions the call context is important, so we link the current CallContext to the instruction. For instance, an SLOAD instruction loads the data from the current contracts storage. If we encounter a call instruction ( CALL , STATICCALL , CALLCODE , DELEGATECALL , CREATE or CREATE2 ) we create a new CallContext . On a STOP , RETURN , REVERT or SELFDESTRUCT we mark the current one as reverted and go back to the previous CallContext . If the depth of the next event is one lower than the current one, we assume an exceptional halt and also revert the current transaction. If the depth of the next event is unexpected, we throw an UnexpectedDepthChange Exception. The Instruction includes: opcode name (mnemonic for opcode) program_counter call_context stack_inputs stack_outputs memory_input memory_output data (additional fields based on the instruction type, eg key for SLOAD )","title":"Parse Instructions and the CallTree"}]}